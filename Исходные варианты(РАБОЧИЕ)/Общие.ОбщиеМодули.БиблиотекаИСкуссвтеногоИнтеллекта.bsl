///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2024, Калимулин Михаил Игоревич, brainguard.ru
// Этот код предоставляется в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

//Начальное заполнение справочников БИИ_Провайдеры и БИИ_Модели БИИ_СхемыБД
Процедура ПроверитьИЗаполнитьСправочники() экспорт
	выб = справочники.БИИ_Провайдеры.Выбрать();
	если не выб.Следующий() тогда
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "OpenAI";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Deepseek";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "01AI";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "ZHIPU";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Anthropic";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Google";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "NVIDIA";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Yandex";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Сбер GigaChat";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "Сбер Salute";
		новпровайдер.Записать();
		новпровайдер = справочники.БИИ_Провайдеры.СоздатьЭлемент();
		новпровайдер.Наименование = "VseGPT";
		новпровайдер.Записать();
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "o1-mini";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "gpt-4o-mini";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "openai/gpt-4o-mini";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("VseGPT");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "gpt-4o";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "openai/gpt-4o";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("VseGPT");
		новмодель.Записать();

		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "deepseek-chat";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Deepseek");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "deepseek-reasoner";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Deepseek");
		новмодель.Записать();

		
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "yi-large";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("01AI");
		новмодель.Записать();
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "glm-4-0520";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("ZHIPU");
		новмодель.Записать();
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "claude-3-opus-20240229";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Anthropic");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "claude-3-5-sonnet-20240620";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Anthropic");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "gemini-pro";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Google");
		новмодель.Записать();

		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "nvidia/nemotron-4-340b-instruct";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("NVIDIA");
		новмодель.Записать();

		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "yandexgpt";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Yandex");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "yandexgpt-lite";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Yandex");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "GigaChat";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Сбер GigaChat");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "GigaChat-Pro";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Сбер GigaChat");
		новмодель.Записать();
		
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "gpt-4o-mini";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "gpt-4o";
		новмодель.Назначение = "Генерация";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "general";
		новмодель.Назначение = "Аудио2Текст";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Yandex");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "saluteSTT";
		новмодель.Назначение = "Аудио2Текст";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Сбер Salute");
		новмодель.Записать();
		

		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "tts-1";
		новмодель.Назначение = "Текст2Аудио";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "tts-1-hd";
		новмодель.Назначение = "Текст2Аудио";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "saluteTTS";
		новмодель.Назначение = "Текст2Аудио";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Сбер Salute");
		новмодель.Записать();
		
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "text-embedding-3-small";
		новмодель.Назначение = "Вектор";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "text-embedding-3-large";
		новмодель.Назначение = "Вектор";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("OpenAI");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "text-search-doc";
		новмодель.Назначение = "Вектор";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Yandex");
		новмодель.Записать();
		новмодель = справочники.БИИ_Модели.СоздатьЭлемент();
		новмодель.Наименование = "text-search-query";
		новмодель.Назначение = "Вектор";
		новмодель.Провайдер = справочники.БИИ_Провайдеры.НайтиПоНаименованию("Yandex");
		новмодель.Записать();
		
	конецесли;
	
	нс = справочники.БИИ_Инструменты.НайтиПоНаименованию("web_search_preview");
	если нс.Пустая() тогда
		нов = справочники.БИИ_Инструменты.СоздатьЭлемент();
		нов.Наименование = "web_search_preview";
		нов.Описание = "Поиск в интернете";
		нов.Встроенный = истина;
		нов.Записать();
	конецесли;
	нс = справочники.БИИ_Инструменты.НайтиПоНаименованию("file_search");
	если нс.Пустая() тогда
		нов = справочники.БИИ_Инструменты.СоздатьЭлемент();
		нов.Наименование = "file_search";
		нов.Описание = "Поиск в векторной базе, RAG";
		нов.Встроенный = истина;
		нов.Записать();
	конецесли;

	
КонецПроцедуры	

//Выдает очередное, еще не обработанное сообщение для бота.
//Результат - структура содержащая сообщение
//Если необработанных ранее сообщений для этого бота нет, тогда неопределено.
//бот - ссылка на элемент справочника БИИ_Боты
Функция ПолучитьСообщениеТелеграм(бот) экспорт
	Соединение = Новый HTTPСоединение("api.telegram.org", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("content-type", "application/json");
	Запрос = Новый HTTPЗапрос(бот.наименование+"/getUpdates?offset="+формат(бот.отступ,"ЧЦ=20; ЧГ=0"), Заголовки);
	Ответ = Соединение.Получить(Запрос);
	ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
	ЧтениеJSON	= Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
	данные = ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();
	если данные.ok тогда
		если данные.result.количество()>0 тогда
			об = бот.ПолучитьОбъект();
			об.отступ = данные.result[0].update_id+1;
			об.записать();
			возврат данные;
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции

//Отправляет сообщение в чат Телеграм
//Результат - код состояния
//бот - ссылка на элемент справочника БИИ_Боты
//чат - номер чата
//текстСообщения - текст сообщения
//меню (необяз.) - структура содержащая меню
Функция ОтправитьСообщениеТелеграм(бот, чат, текстСообщения, меню=неопределено) экспорт
	Соединение = Новый HTTPСоединение("api.telegram.org", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
	данные=новый структура;
	данные.Вставить("chat_id",формат(чат,"ЧЦ=16; ЧГ=0"));
	данные.Вставить("text",текстСообщения);
	если меню<>неопределено тогда 
		данные.Вставить("reply_markup",меню);
	конецесли;	
	ЗаписьJSON=новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON,данные);
	строказапроса=ЗаписьJSON.Закрыть();
	Заголовки   = Новый Соответствие;
	Заголовки.Вставить("content-type", "application/json");
	Запрос = Новый HTTPЗапрос(бот.наименование+"/sendMessage", Заголовки);
	Запрос.УстановитьТелоИзСтроки(строказапроса);
	ответ = Соединение.ОтправитьДляОбработки(Запрос);
	возврат ответ.КодСостояния;
КонецФункции	

//Отправляет голосовое сообщение в чат Телеграм
//Результат - код состояния
//бот - ссылка на элемент справочника БИИ_Боты
//чат - номер чата
//аудиофайл - путь к файлу в формате mp3
//меню (необяз.) - структура содержащая меню
Функция ОтправитьАудиоТелеграм(бот, чат, аудиофайл, меню=неопределено) экспорт
	//данные=новый структура;
	//данные.Вставить("chat_id",формат(чат,"ЧЦ=16; ЧГ=0"));
	//если меню<>неопределено тогда 
	//	данные.Вставить("reply_markup",меню);
	//конецесли;	
	Boundary = "----"+Строка(Новый УникальныйИдентификатор());
	мо = новый массив;
	ИмяФайлаГолова = ПолучитьИмяВременногоФайла("txt");
	флголова = Новый ЗаписьТекста(ИмяФайлаГолова, КодировкаТекста.UTF8);
	ИмяФайлаХвост = ПолучитьИмяВременногоФайла("txt");
	флхвост = Новый ЗаписьТекста(ИмяФайлаХвост, КодировкаТекста.UTF8);
	тх = "--"+Boundary + Символы.ПС;
	тх = тх + "Content-Disposition: form-data; name=""chat_id""" + Символы.ПС + Символы.ПС;
	тх = тх + Формат(чат, "ЧГ=0") + Символы.ПС;
	если меню<>неопределено тогда
		ЗаписьJSON=новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON,меню);
		строкаменю=ЗаписьJSON.Закрыть();
		тх = тх + "--"+Boundary + Символы.ПС;
		тх = тх + "Content-Disposition: form-data; name=""reply_markup""" + Символы.ПС;
		тх = тх + "Content-Type: application/json" + Символы.ПС + Символы.ПС;
		тх = тх + строкаменю + Символы.ПС;
	конецесли;

	тх = тх + "--"+Boundary + Символы.ПС;
	тх = тх + "Content-Disposition: form-data; name=""voice""; filename=""voice.mp3""" + Символы.ПС;
	флголова.ЗаписатьСтроку(тх);
	флголова.Закрыть();
	
	мо.Добавить(ИмяФайлаГолова);
	мо.Добавить(аудиофайл);
	тх = Символы.ПС + "--"+Boundary+"--";
	флхвост.ЗаписатьСтроку(тх);
	флхвост.Закрыть();
	мо.Добавить(ИмяФайлаХвост);
	ИмяФайлаОтправки = ПолучитьИмяВременногоФайла("txt");
	ОбъединитьФайлы(мо, ИмяФайлаОтправки);
	
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Connection", "keep-alive");
	Заголовки.Вставить("Content-Type", "multipart/form-data; boundary="+Boundary);
	Запрос = Новый HTTPЗапрос(бот.наименование+"/sendVoice", Заголовки);
	Запрос.УстановитьИмяФайлаТела(ИмяФайлаОтправки);
	Соединение = Новый HTTPСоединение("api.telegram.org", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
	ответ = Соединение.ОтправитьДляОбработки(Запрос);
	возврат ответ.КодСостояния;
КонецФункции	

//Выдает аудио данные из сообщения
//Результат - двоичные данные, если в сообщении нет аудио, тогда неопределено 
//бот - ссылка на элемент справочника БИИ_Боты
//сообщение - структура содержащая сообщение
Функция ПолучитьАудиоДанныеТелеграм(бот, сообщение) экспорт
	если сообщение.result[0].message.свойство("voice") тогда
		идфайла = сообщение.result[0].message.voice.file_id;
		Соединение = Новый HTTPСоединение("api.telegram.org", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
		Заголовки   = Новый Соответствие;
		Заголовки.Вставить("content-type", "application/json");
		Запрос = Новый HTTPЗапрос(бот.наименование+"/getFile?file_id="+идфайла, Заголовки);
		Ответ = Соединение.Получить(Запрос);
		ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
		ЧтениеJSON	= Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
		данные = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		если данные.ok тогда
			путькфайлу = данные.result.file_path;
			Соединение = Новый HTTPСоединение("api.telegram.org", 443, , , , , Новый ЗащищенноеСоединениеOpenSSL());
			Запрос = Новый HTTPЗапрос("file/"+бот.наименование+"/"+путькфайлу);
			Ответ = Соединение.Получить(Запрос);
			если ответ.КодСостояния=200 тогда
				возврат Ответ.ПолучитьТелоКакДвоичныеДанные();
			конецесли;	
		конецесли;	
	конецесли;		
	возврат неопределено;
КонецФункции

//Выдает текст, расшифрованный из аудио данных
//Результат - расшифрованный текст или неопределено в случае ошибки 
//аудио - двоичные данные, содержащие аудио
//модель - ссылка на элемент справочника БИИ_Модели
Функция ПолучитьТекстИзАудио(аудио, модель) экспорт
	если модель.назначение="Аудио2Текст" тогда
		если модель.провайдер.наименование="Yandex" тогда
			Соединение = новый HTTPСоединение("stt.api.cloud.yandex.net",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = новый Соответствие;
			Заголовки.Вставить("Authorization", "Api-Key "+модель.провайдер.ключ);
			Запрос = новый HTTPЗапрос("speech/v1/stt:recognize?topic=general&lang=ru-RU", Заголовки);
			Запрос.УстановитьТелоИзДвоичныхДанных(аудио);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON	= Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данные = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если ответ.КодСостояния=200 тогда
				возврат данные.result;
			конецесли;
		иначеесли модель.провайдер.наименование="Сбер" тогда
			уид=строка(новый УникальныйИдентификатор());
			Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru",9443,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Authorization", "Basic "+модель.провайдер.ключ);
			Заголовки.Вставить("RqUID", уид);
			Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
			Запрос = Новый HTTPЗапрос("api/v2/oauth", Заголовки);
			Запрос.УстановитьТелоИзСтроки("scope=SALUTE_SPEECH_PERS");
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			если Ответ.КодСостояния=200 тогда
				ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
				ЧтениеJSON=Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
				данныеответа=ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				токен=данныеответа.access_token;
				Соединение = Новый HTTPСоединение("smartspeech.sber.ru",,,,,,новый ЗащищенноеСоединениеOpenSSL());
				Заголовки = Новый Соответствие;
				Заголовки.Вставить("Content-Type", "audio/ogg;codecs=opus");
				Заголовки.Вставить("Authorization", "Bearer "+токен);
				Запрос = Новый HTTPЗапрос("rest/v1/speech:recognize", Заголовки);
				Запрос.УстановитьТелоИзДвоичныхДанных(аудио);
				Ответ = Соединение.ОтправитьДляОбработки(Запрос);
				ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
				ЧтениеJSON	= Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
				данные = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				если Ответ.КодСостояния=200 тогда
					возврат данные.result[0];
				конецесли;	
			конецесли;	
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции	

//Синтезирует речь из текста
//Результат - двоичные данные или неопределено в случае ошибки 
//текст - исходный текст
//модель - ссылка на элемент справочника БИИ_Модели
Функция ПолучитьАудиоИзТекста(текст, модель) экспорт
	если модель.назначение="Текст2Аудио" тогда
		если модель.провайдер.наименование="Сбер Salute" тогда
			уид=строка(новый УникальныйИдентификатор());
			Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru",9443,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Authorization", "Basic "+модель.провайдер.ключ);
			Заголовки.Вставить("RqUID", уид);
			Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
			Запрос = Новый HTTPЗапрос("api/v2/oauth", Заголовки);
			Запрос.УстановитьТелоИзСтроки("scope=SALUTE_SPEECH_PERS");
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			если Ответ.КодСостояния=200 тогда
				ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
				ЧтениеJSON=Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
				данныеответа=ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				токен=данныеответа.access_token;
				Соединение = Новый HTTPСоединение("smartspeech.sber.ru",,,,,,новый ЗащищенноеСоединениеOpenSSL());
				Заголовки = Новый Соответствие;
				Заголовки.Вставить("Content-Type", "application/text");
				Заголовки.Вставить("Authorization", "Bearer "+токен);
				Запрос = Новый HTTPЗапрос("rest/v1/text:synthesize", Заголовки);
				Запрос.УстановитьТелоИзСтроки(текст);
				Ответ = Соединение.ОтправитьДляОбработки(Запрос);
				если Ответ.КодСостояния=200 тогда
					возврат Ответ.ПолучитьТелоКакДвоичныеДанные();
				конецесли;	
			конецесли;	
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции	

//Основная функция. Используется технология GPT для генерации текста
//Результат - текст ответа большой языковой модели (LLM) или неопределено в случае ошибки.
//Если установлен параметр полный_результат, тогда результат это структура:
//ТекстОтвета, Размышления, ВходныеТокены, ВходныеТокеныВКеше, ВходныеТокеныЗаКешем, ВыходныеТокены
//
//промт - текст запроса пользователя или структура с ключами: текст, изображение (изображение в свою очередь структура с ключами тип, данные)
//модель - ссылка на элемент справочника БИИ_Модели
//семплирование (необяз.)- число, уровень "креативности" ответа, 0-минимум креативности
//инструменты (необяз.) - массив ссылок на элементы справочника БИИ_Инструменты или JSON схема 
//системный_промт (необяз.) - системный промт
//полный_результат (необяз.) - возвращать полный результат
//опции (необяз.) - дополнительные опции, структура содержащая дополнительные опции, может отличаться у разных провайдеров
Функция Генерация(промт, модель, семплирование=0, инструменты=неопределено, системный_промт=неопределено, полный_результат=ложь, схема_ответа=неопределено, опции=неопределено) экспорт
	если модель.назначение="Генерация" тогда
		если модель.провайдер.наименование="OpenAI" тогда
			Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/chat/completions", Заголовки);
			мСообщений = новый массив;
			если системный_промт<>неопределено тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","system");
				стСообщение.Вставить("content",системный_промт);
				мСообщений.Добавить(стСообщение);
			конецесли;
			если строка(типзнч(промт))="Строка" тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",промт);
			иначе
				мТиповВвода = новый массив;
				стТекст = новый структура;
				стТекст.Вставить("type","text");
				стТекст.Вставить("text",промт.текст);
				мТиповВвода.Добавить(стТекст);
				стИзображение = новый структура;
				стИзображениеДетали = новый структура;
				стИзображениеДетали.Вставить("url","data:"+промт.тип+";base64,"+промт.изображение);
				стИзображениеДетали.Вставить("detail","high");
				стИзображение.Вставить("type","image_url");
				стИзображение.Вставить("image_url",стИзображениеДетали);
				мТиповВвода.Добавить(стИзображение);
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",мТиповВвода);
			конецесли;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			если не модель.думающая тогда
				данные.Вставить("temperature",семплирование);
			конецесли;	
			если строка(типзнч(инструменты))="Строка" тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(инструменты);	
				минст = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				данные.Вставить("tools",минст);
			иначеесли строка(типзнч(инструменты))="Массив" тогда
				минст = новый массив;
				для каждого инст из инструменты цикл
					стинст = новый структура;
					стинст.Вставить("type","function");
					стф = новый структура;
					стф.Вставить("description",инст.описание);
					стф.Вставить("name",инст.Наименование);
					если инст.параметрыфункции.количество()>0 тогда
						стпар = новый структура;
						стпар.Вставить("type","object");
						стсв = новый структура;
						мобяз = новый массив;
						для каждого пар из инст.параметрыфункции цикл
							стзн = новый структура;
							стзн.Вставить("type",пар.тип);
							если значениезаполнено(пар.описание) тогда
								описаниепараметра=стрзаменить(пар.описание,"{database_schema_string}",ПолучитьСхемуБД(инст));
								стзн.Вставить("description",описаниепараметра);
							конецесли;
							если значениезаполнено(пар.перечень) тогда
								мперечень = стрразделить(пар.перечень,",");
								стзн.Вставить("enum",мперечень);
							конецесли;
							стсв.Вставить(пар.имя,стзн);
							если пар.обязательный тогда
								мобяз.Добавить(пар.имя);
							конецесли;	
						конеццикла;	
						стпар.Вставить("properties",стсв);
						стпар.Вставить("required",мобяз);
						стф.Вставить("parameters",стпар);
					конецесли;
					стинст.Вставить("function",стф);
					минст.Добавить(стинст);
				конеццикла;
				данные.Вставить("tools",минст);
			конецесли;
			если схема_ответа<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(схема_ответа);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				стформат = новый структура;
				стформат.Вставить("type","json_schema");
				стформат.Вставить("json_schema",схема);
				данные.Вставить("response_format",стформат);
			конецесли;
			
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если данныеответа.choices[0].finish_reason="tool_calls" тогда
					возврат данныеответа.choices[0].message.tool_calls;
				иначе
					если полный_результат тогда
						ст = новый структура;
						ст.Вставить("ТекстОтвета",данныеответа.choices[0].message.content);
						если модель.думающая тогда
							ст.Вставить("Размышления",данныеответа.choices[0].message.reasoning_content);
						иначе	
							ст.Вставить("Размышления","");
						конецесли;
						ст.Вставить("ВходныеТокены",данныеответа.usage.prompt_tokens);
						ст.Вставить("ВходныеТокеныВКеше",данныеответа.usage.prompt_tokens_details.cached_tokens);
						ст.Вставить("ВходныеТокеныЗаКешем",ст.ВходныеТокены-ст.ВходныеТокеныВКеше);
						ст.Вставить("ВыходныеТокены",данныеответа.usage.completion_tokens);
						возврат ст;
					иначе	
						возврат данныеответа.choices[0].message.content;
					конецесли;	
				конецесли;
			конецесли;
		иначеесли модель.провайдер.наименование="Deepseek" тогда
			Соединение = Новый HTTPСоединение("api.deepseek.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("chat/completions", Заголовки);
			мСообщений = новый массив;
			если системный_промт<>неопределено тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","system");
				стСообщение.Вставить("content",системный_промт);
				мСообщений.Добавить(стСообщение);
			конецесли;	
			стСообщение = новый структура;
			стСообщение.Вставить("role","user");
			стСообщение.Вставить("content",промт);
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			данные.Вставить("temperature",семплирование);
			если строка(типзнч(инструменты))="Строка" тогда
				ЧтениеJSON=Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(инструменты);	
				минст=ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				данные.Вставить("tools",минст);
			иначеесли строка(типзнч(инструменты))="Массив" тогда
				минст = новый массив;
				для каждого инст из инструменты цикл
					стинст = новый структура;
					стинст.Вставить("type","function");
					стф = новый структура;
					стф.Вставить("description",инст.описание);
					стф.Вставить("name",инст.Наименование);
					если инст.параметрыфункции.количество()>0 тогда
						стпар = новый структура;
						стпар.Вставить("type","object");
						стсв = новый структура;
						мобяз = новый массив;
						для каждого пар из инст.параметрыфункции цикл
							стзн = новый структура;
							стзн.Вставить("type",пар.тип);
							если значениезаполнено(пар.описание) тогда
								описаниепараметра=стрзаменить(пар.описание,"{database_schema_string}",ПолучитьСхемуБД(инст));
								стзн.Вставить("description",описаниепараметра);
							конецесли;
							если значениезаполнено(пар.перечень) тогда
								мперечень = стрразделить(пар.перечень,",");
								стзн.Вставить("enum",мперечень);
							конецесли;
							стсв.Вставить(пар.имя,стзн);
							если пар.обязательный тогда
								мобяз.Добавить(пар.имя);
							конецесли;	
						конеццикла;	
						стпар.Вставить("properties",стсв);
						стпар.Вставить("required",мобяз);
						стф.Вставить("parameters",стпар);
					конецесли;
					стинст.Вставить("function",стф);
					минст.Добавить(стинст);
				конеццикла;
				данные.Вставить("tools",минст);
			конецесли;

			если схема_ответа<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(схема_ответа);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				стформат = новый структура;
				стформат.Вставить("type","json_schema");
				стформат.Вставить("json_schema",схема);
				данные.Вставить("response_format",стформат);
			конецесли;
			
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если данныеответа.choices[0].finish_reason="tool_calls" тогда
					возврат данныеответа.choices[0].message.tool_calls;
				иначе
					если полный_результат тогда
						ст = новый структура;
						ст.Вставить("ТекстОтвета",данныеответа.choices[0].message.content);
						если модель.думающая тогда
							ст.Вставить("Размышления",данныеответа.choices[0].message.reasoning_content);
						иначе	
							ст.Вставить("Размышления","");
						конецесли;
						ст.Вставить("ВходныеТокены",данныеответа.usage.prompt_tokens);
						ст.Вставить("ВходныеТокеныВКеше",данныеответа.usage.prompt_cache_hit_tokens);
						ст.Вставить("ВходныеТокеныЗаКешем",данныеответа.usage.prompt_cache_miss_tokens);
						ст.Вставить("ВыходныеТокены",данныеответа.usage.completion_tokens);
						возврат ст;
					иначе	
						возврат данныеответа.choices[0].message.content;
					конецесли;	
				конецесли;
			конецесли;
		иначеесли модель.провайдер.наименование="01AI" тогда
			Соединение = Новый HTTPСоединение("api.01.ai",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/chat/completions", Заголовки);
			стСообщение = новый структура;
			стСообщение.Вставить("role","user");
			стСообщение.Вставить("content",промт);
			мСообщений = новый массив;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			данные.Вставить("temperature",семплирование);
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа=ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.choices[0].message.content;
			конецесли;
		иначеесли модель.провайдер.наименование="ZHIPU" тогда
			Соединение = Новый HTTPСоединение("open.bigmodel.cn",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("api/paas/v4/chat/completions", Заголовки);
			стСообщение = новый структура;
			стСообщение.Вставить("role","user");
			стСообщение.Вставить("content",промт);
			мСообщений = новый массив;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			данные.Вставить("temperature",макс(семплирование,0.01));
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа=ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.choices[0].message.content;
			конецесли;
		иначеесли модель.провайдер.наименование="NVIDIA" тогда
			Соединение = Новый HTTPСоединение("integrate.api.nvidia.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/chat/completions", Заголовки);
			стСообщение = новый структура;
			стСообщение.Вставить("role","user");
			стСообщение.Вставить("content",промт);
			мСообщений = новый массив;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			данные.Вставить("temperature",макс(семплирование,0.1));
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа=ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.choices[0].message.content;
			конецесли;
		иначеесли модель.провайдер.наименование="Anthropic" тогда
			Соединение = Новый HTTPСоединение("api.anthropic.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("x-api-key", модель.провайдер.ключ);
			Заголовки.Вставить("anthropic-version", "2023-06-01");
			Запрос = Новый HTTPЗапрос("v1/messages", Заголовки);

			если строка(типзнч(промт))="Строка" тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				если значениезаполнено(системный_промт) тогда
					стСообщение.Вставить("content",системный_промт+" "+промт);
				иначе	
					стСообщение.Вставить("content",промт);
				конецесли;
			иначе
				мТиповВвода = новый массив;
				стТекст = новый структура;
				стТекст.Вставить("type","text");
				если значениезаполнено(системный_промт) тогда
					стТекст.Вставить("text",системный_промт+" "+промт.текст);
				иначе	
					стТекст.Вставить("text",промт.текст);
				конецесли;
				мТиповВвода.Добавить(стТекст);
				стИзображение = новый структура;
				стИзображениеДетали = новый структура;
				стИзображениеДетали.Вставить("type","base64");
				стИзображениеДетали.Вставить("media_type",промт.тип);
				стИзображениеДетали.Вставить("data",стрзаменить(стрзаменить(промт.изображение,символы.ПС,""),символы.ВК,""));
				стИзображение.Вставить("type","image");
				стИзображение.Вставить("source",стИзображениеДетали);
				мТиповВвода.Добавить(стИзображение);
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",мТиповВвода);
			конецесли;

			мСообщений = новый массив;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			
			думающая = ложь;
			если опции<>неопределено тогда
				если опции.свойство("thinking") тогда
					думающая = истина;
				конецесли;
			конецесли;	
			
			если не думающая тогда
				если строка(типзнч(семплирование))="Число" тогда
					данные.Вставить("temperature",макс(семплирование,0.01));
				иначе
					если семплирование.Свойство("temperature") тогда
						данные.Вставить("temperature",макс(семплирование.temperature,0.01));
					иначеесли семплирование.Свойство("top_p") тогда
						данные.Вставить("top_p",семплирование.top_p);
					иначеесли семплирование.Свойство("top_k") тогда
						данные.Вставить("top_k",семплирование.top_k);
					конецесли;	
				конецесли;
			конецесли;
		
			данные.Вставить("max_tokens",8000);
			
			если инструменты<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(инструменты);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				данные.Вставить("tools",схема);
			иначеесли схема_ответа<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(схема_ответа);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				м = новый массив;
				м.Добавить(схема);
				данные.Вставить("tools",м);
			конецесли;
			
			если думающая тогда
				данные.Вставить("thinking",опции.thinking);
			конецесли;	
			
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON=Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа=ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если данныеответа.stop_reason="tool_use" тогда
					для каждого кнт из данныеответа.content цикл
						если кнт.type="tool_use" тогда
							ЗаписьJSON = новый ЗаписьJSON;
							ЗаписьJSON.УстановитьСтроку();
							ЗаписатьJSON(ЗаписьJSON,кнт.input);
							текстответа = ЗаписьJSON.Закрыть();
							возврат текстответа;
						конецесли;
					конеццикла;
				иначе
					результат_текст = "";
					результат_размышления = "";
					для каждого кнт из данныеответа.content цикл
						если кнт.type="text" тогда
							результат_текст = кнт.text;
						иначеесли кнт.type="thinking" тогда
							результат_размышления = кнт.thinking;
						конецесли;	
					конеццикла;	
					если полный_результат тогда
						ст = новый структура;
						ст.Вставить("ТекстОтвета",результат_текст);
						ст.Вставить("Размышления",результат_размышления);
						ст.Вставить("ВходныеТокены",данныеответа.usage.input_tokens);
						ст.Вставить("ВходныеТокеныВКеше",данныеответа.usage.cache_read_input_tokens);
						ст.Вставить("ВходныеТокеныЗаКешем",данныеответа.usage.cache_creation_input_tokens);
						ст.Вставить("ВыходныеТокены",данныеответа.usage.output_tokens);
						возврат ст;
					иначе	
						возврат результат_текст;
					конецесли;	
				конецесли;	
			конецесли;	
		иначеесли модель.провайдер.наименование="Yandex" тогда
			Соединение=новый HTTPСоединение("llm.api.cloud.yandex.net",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки=новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Api-Key "+модель.Провайдер.Ключ);
			Запрос=новый HTTPЗапрос("foundationModels/v1/completion", Заголовки);
			стСообщение=новый структура;
			стСообщение.Вставить("role","user");
			стСообщение.Вставить("text",промт);
			мСообщений=новый массив;
			мСообщений.Добавить(стСообщение);
			данные=новый структура;
			данные.Вставить("modelUri","gpt://"+модель.Провайдер.Каталог+"/"+сокрлп(модель));
			ст=новый структура;
			ст.Вставить("stream",ложь);
			ст.Вставить("temperature",семплирование);
			ст.Вставить("maxTokens","4000");
			если опции<>неопределено тогда
				если опции.свойство("reasoningOptions") тогда
					ст.Вставить("reasoningOptions",опции.reasoningOptions);
				конецесли;	
			конецесли;	
			
			данные.Вставить("completionOptions",ст);
			данные.Вставить("messages",мСообщений);

			если инструменты<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(инструменты);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				данные.Вставить("tools",схема);
			конецесли;
			
			ЗаписьJSON=новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса=ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ=Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON	= Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				рез = данныеответа.result.alternatives[0].message.text;
				если лев(рез,5)="[CLS]" тогда
					мф = новый массив;
					ст = новый структура;
					ст.Вставить("name",сред(СтрПолучитьСтроку(рез,1),6));
					ст.Вставить("arguments",СтрПолучитьСтроку(рез,2));
					стф = новый структура;
					стф.Вставить("Function",ст);
					мф.Добавить(стф);
					возврат мф;
				иначе	
					возврат рез;
				конецесли;	
			конецесли;
		иначеесли модель.провайдер.наименование="Сбер GigaChat" тогда
			уид=строка(новый УникальныйИдентификатор());
			Соединение = Новый HTTPСоединение("ngw.devices.sberbank.ru",9443,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Authorization", "Basic "+модель.Провайдер.Ключ);
			Заголовки.Вставить("RqUID", уид);
			Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
			Запрос = Новый HTTPЗапрос("api/v2/oauth", Заголовки);
			Запрос.УстановитьТелоИзСтроки("scope=GIGACHAT_API_PERS");
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			если Ответ.КодСостояния=200 тогда
				ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
				ЧтениеJSON=Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
				данныеответа=ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				токен=данныеответа.access_token;
			иначе
				токен=неопределено;
			конецесли;	
			
			если токен<>неопределено тогда
				Соединение = Новый HTTPСоединение("gigachat.devices.sberbank.ru",,,,,,новый ЗащищенноеСоединениеOpenSSL());
				Заголовки = Новый Соответствие;
				Заголовки.Вставить("Content-Type", "application/json");
				Заголовки.Вставить("Authorization", "Bearer "+токен);
				Запрос = Новый HTTPЗапрос("api/v1/chat/completions", Заголовки);
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",промт);
				мСообщений = новый массив;
				мСообщений.Добавить(стСообщение);
				данные = новый структура;
				данные.Вставить("model",сокрлп(модель));
				данные.Вставить("messages",мСообщений);
				данные.Вставить("temperature",семплирование);
				данные.Вставить("max_tokens",1000);
				ЗаписьJSON = новый ЗаписьJSON;
				ЗаписьJSON.УстановитьСтроку();
				ЗаписатьJSON(ЗаписьJSON,данные);
				строказапроса = ЗаписьJSON.Закрыть();
				Запрос.УстановитьТелоИзСтроки(строказапроса);
				Ответ = Соединение.ОтправитьДляОбработки(Запрос);
				если Ответ.КодСостояния=200 тогда
					ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
					ЧтениеJSON=Новый ЧтениеJSON;
					ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
					данныеответа=ПрочитатьJSON(ЧтениеJSON);
					ЧтениеJSON.Закрыть();
					возврат данныеответа.choices[0].message.content;
				конецесли;	
			конецесли;
		иначеесли модель.провайдер.наименование="Google" тогда
			Соединение = Новый HTTPСоединение("generativelanguage.googleapis.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Запрос = Новый HTTPЗапрос("v1/models/gemini-pro:generateContent?key="+модель.Провайдер.Ключ, Заголовки);
			данные = новый структура;
			мс = новый массив;
			стч = новый структура;
			мч = новый массив;
			стт = новый структура;
			стт.Вставить("text",промт);
			мч.Добавить(стт);
			стч.Вставить("parts",мч);
			мс.Добавить(стч);
			данные.Вставить("contents",мс);
			стт = новый структура;
			стт.Вставить("temperature",семплирование);
			данные.Вставить("generationConfig",стт);
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			если Ответ.КодСостояния=200 тогда
				ОтветСтрока=Ответ.ПолучитьТелоКакСтроку();
				ЧтениеJSON=Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
				данныеответа=ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				возврат данныеответа.candidates[0].content.parts[0].text;
			конецесли;
		иначеесли модель.провайдер.наименование="VseGPT" тогда
			Соединение = Новый HTTPСоединение("api.vsegpt.ru",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/chat/completions", Заголовки);
			мСообщений = новый массив;
			если системный_промт<>неопределено тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","system");
				стСообщение.Вставить("content",системный_промт);
				мСообщений.Добавить(стСообщение);
			конецесли;
			если строка(типзнч(промт))="Строка" тогда
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",промт);
			иначе
				мТиповВвода = новый массив;
				стТекст = новый структура;
				стТекст.Вставить("type","text");
				стТекст.Вставить("text",промт.текст);
				мТиповВвода.Добавить(стТекст);
				стИзображение = новый структура;
				стИзображениеДетали = новый структура;
				стИзображениеДетали.Вставить("url",промт.изображение);
				стИзображениеДетали.Вставить("detail","high");
				стИзображение.Вставить("type","image_url");
				стИзображение.Вставить("image_url",стИзображениеДетали);
				мТиповВвода.Добавить(стИзображение);
				стСообщение = новый структура;
				стСообщение.Вставить("role","user");
				стСообщение.Вставить("content",мТиповВвода);
			конецесли;
			мСообщений.Добавить(стСообщение);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("messages",мСообщений);
			если не модель.думающая тогда
				данные.Вставить("temperature",семплирование);
			конецесли;	
			если строка(типзнч(инструменты))="Строка" тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(инструменты);	
				минст = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				данные.Вставить("tools",минст);
			иначеесли строка(типзнч(инструменты))="Массив" тогда
				минст = новый массив;
				для каждого инст из инструменты цикл
					стинст = новый структура;
					стинст.Вставить("type","function");
					стф = новый структура;
					стф.Вставить("description",инст.описание);
					стф.Вставить("name",инст.Наименование);
					если инст.параметрыфункции.количество()>0 тогда
						стпар = новый структура;
						стпар.Вставить("type","object");
						стсв = новый структура;
						мобяз = новый массив;
						для каждого пар из инст.параметрыфункции цикл
							стзн = новый структура;
							стзн.Вставить("type",пар.тип);
							если значениезаполнено(пар.описание) тогда
								описаниепараметра=стрзаменить(пар.описание,"{database_schema_string}",ПолучитьСхемуБД(инст));
								стзн.Вставить("description",описаниепараметра);
							конецесли;
							если значениезаполнено(пар.перечень) тогда
								мперечень = стрразделить(пар.перечень,",");
								стзн.Вставить("enum",мперечень);
							конецесли;
							стсв.Вставить(пар.имя,стзн);
							если пар.обязательный тогда
								мобяз.Добавить(пар.имя);
							конецесли;	
						конеццикла;	
						стпар.Вставить("properties",стсв);
						стпар.Вставить("required",мобяз);
						стф.Вставить("parameters",стпар);
					конецесли;
					стинст.Вставить("function",стф);
					минст.Добавить(стинст);
				конеццикла;
				данные.Вставить("tools",минст);
			конецесли;
			если схема_ответа<>неопределено тогда
				ЧтениеJSON = Новый ЧтениеJSON;
				ЧтениеJSON.УстановитьСтроку(схема_ответа);	
				схема = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				стформат = новый структура;
				стформат.Вставить("type","json_schema");
				стформат.Вставить("json_schema",схема);
				данные.Вставить("response_format",стформат);
			конецесли;
			
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если данныеответа.choices[0].finish_reason="tool_calls" тогда
					возврат данныеответа.choices[0].message.tool_calls;
				иначе
					если полный_результат тогда
						ст = новый структура;
						ст.Вставить("ТекстОтвета",данныеответа.choices[0].message.content);
						если модель.думающая тогда
							ст.Вставить("Размышления",данныеответа.choices[0].message.reasoning_content);
						иначе	
							ст.Вставить("Размышления","");
						конецесли;
						ст.Вставить("ВходныеТокены",данныеответа.usage.prompt_tokens);
						ст.Вставить("ВходныеТокеныВКеше",данныеответа.usage.prompt_tokens_details.cached_tokens);
						ст.Вставить("ВходныеТокеныЗаКешем",ст.ВходныеТокены-ст.ВходныеТокеныВКеше);
						ст.Вставить("ВыходныеТокены",данныеответа.usage.completion_tokens);
						возврат ст;
					иначе	
						возврат данныеответа.choices[0].message.content;
					конецесли;	
				конецесли;
			конецесли;
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции

//Response новый API от OpenAI
//Результат - текст ответа большой языковой модели (LLM) или неопределено в случае ошибки.
//промт - текст запроса пользователя или структура с ключами: текст, изображение (изображение в свою очередь структура с ключами тип, данные)
//модель - ссылка на элемент справочника БИИ_Модели
//инструменты (необяз.) - массив ссылок на элементы справочника БИИ_Инструменты 
//опции (необяз.) - структура, содержащая доп. опции
//полный_ответ (необяз.) - булево, выдавать полный ответ
Функция Ответ(промт, модель, инструменты=неопределено, опции=неопределено, полный_ответ=ложь) экспорт
	если модель.назначение="Генерация" тогда
		если модель.провайдер.наименование="OpenAI" тогда
			Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/responses", Заголовки);
			данные = новый структура;
			данные.Вставить("model",сокрлп(модель));
			данные.Вставить("input",промт);
			если инструменты<>неопределено тогда
				минст = новый массив;
				для каждого инструмент из инструменты цикл
					ст = новый структура;
					если инструмент.встроенный тогда
						ст.Вставить("type",инструмент.наименование);
						если инструмент.наименование="file_search" тогда
							мвб = новый массив;
							мвб.Добавить(опции.vector_store_id);
							ст.Вставить("vector_store_ids",мвб);
						конецесли;	
					иначе
						//вызовы функций
					конецесли;
					минст.Добавить(ст);
				конеццикла;
				данные.Вставить("tools",минст);
			конецесли;
			если опции<>неопределено тогда
				если опции.свойство("previous_response_id") тогда
					данные.Вставить("previous_response_id",опции.previous_response_id);
				конецесли;	
			конецесли;	
			
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если полный_ответ тогда
					ст = новый структура;
					ст.Вставить("id",данныеответа.id);
					для каждого стр из данныеответа.output цикл
						если стр.type="message" тогда
							ст.Вставить("ТекстОтвета",стр.content[0].text); 
						конецесли;	
					конеццикла;
					возврат ст;
				иначе	
					для каждого стр из данныеответа.output цикл
						если стр.type="message" тогда
							возврат стр.content[0].text; 
						конецесли;	
					конеццикла;
				конецесли;
			конецесли;
		конецесли;
	конецесли;
КонецФункции

//Получение вектора(embedding)
//Результат - массив чисел (векторное представление текста) или неопределено в случае ошибки 
//текст - исходный текст
//модель - ссылка на элемент справочника БИИ_Модели
Функция Вектор(текст, модель) экспорт
	если модель.назначение="Вектор" тогда
		если модель.провайдер.наименование="OpenAI" тогда
			Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = Новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Bearer "+модель.провайдер.ключ);
			Запрос = Новый HTTPЗапрос("v1/embeddings", Заголовки);
			данные = новый структура;
			данные.Вставить("input",текст);
			данные.Вставить("model",сокрлп(модель));
			ЗаписьJSON = новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса = ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ = Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа=ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.data[0].embedding;
			конецесли;
		иначеесли модель.провайдер.наименование="Yandex" тогда
			Соединение=новый HTTPСоединение("llm.api.cloud.yandex.net",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки=новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Api-Key "+модель.Провайдер.Ключ);
			Запрос=новый HTTPЗапрос("foundationModels/v1/textEmbedding", Заголовки);
			данные=новый структура;
			данные.Вставить("modelUri","emb://"+модель.Провайдер.Каталог+"/"+сокрлп(модель));
			данные.Вставить("text",текст);
			ЗаписьJSON=новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса=ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ=Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON	= Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.embedding;
			конецесли;
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции

//Запрос на формирование изображения по описанию (асинхронный)
//Результат - id запроса на создание изображения (далее его можно будет использовать в функции ПолучитьИзображение()) или неопределено в случае ошибки 
//промт - описание изображения
//модель - ссылка на элемент справочника БИИ_Модели
Функция ЗапроситьИзображение(промт, модель) экспорт
	если модель.назначение="Текст2Графика" тогда
		если модель.провайдер.наименование="OpenAI" тогда
		иначеесли модель.провайдер.наименование="Yandex" тогда
			Соединение = новый HTTPСоединение("llm.api.cloud.yandex.net",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Api-Key "+модель.Провайдер.Ключ);
			Запрос = новый HTTPЗапрос("foundationModels/v1/imageGenerationAsync", Заголовки);
			данные = новый структура;
			данные.Вставить("modelUri","art://"+модель.Провайдер.Каталог+"/"+сокрлп(модель));
			мСообщений = новый массив;
			ст = новый структура;
			ст.Вставить("weight",1);
			ст.Вставить("text",сокрлп(промт));
			мСообщений.Добавить(ст);
			данные.Вставить("messages",мСообщений);
			ЗаписьJSON=новый ЗаписьJSON;
			ЗаписьJSON.УстановитьСтроку();
			ЗаписатьJSON(ЗаписьJSON,данные);
			строказапроса=ЗаписьJSON.Закрыть();
			Запрос.УстановитьТелоИзСтроки(строказапроса);
			Ответ=Соединение.ОтправитьДляОбработки(Запрос);
			ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
			ЧтениеJSON	= Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				возврат данныеответа.id;
			конецесли;
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции

//Получение изображения, которое было сфоримровано ранее по запросу ЗапроситьИзображение()
//Результат - изображение закодированное в base64 или неопределено 
//идентификатор - идентификатор изображения, полученный ранее функцией ЗапроситьИзображение()
//модель - ссылка на элемент справочника БИИ_Модели
Функция ПолучитьИзображение(идентификатор, модель) экспорт
	если модель.назначение="Текст2Графика" тогда
		если модель.провайдер.наименование="OpenAI" тогда
		иначеесли модель.провайдер.наименование="Yandex" тогда
			Соединение = новый HTTPСоединение("llm.api.cloud.yandex.net",,,,,,новый ЗащищенноеСоединениеOpenSSL());
			Заголовки = новый Соответствие;
			Заголовки.Вставить("Content-Type", "application/json");
			Заголовки.Вставить("Authorization", "Api-Key "+модель.Провайдер.Ключ);
			Запрос = новый HTTPЗапрос("operations/"+идентификатор, Заголовки);
			Ответ=Соединение.Получить(Запрос);
			ОтветСтрока = ответ.ПолучитьТелоКакСтроку();
			ОтветСтрока = стрзаменить(ОтветСтрока,"@type","dogtype");
			ЧтениеJSON	= Новый ЧтениеJSON;
			ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
			данныеответа = ПрочитатьJSON(ЧтениеJSON);
			ЧтениеJSON.Закрыть();
			если Ответ.КодСостояния=200 тогда
				если данныеответа.done тогда
					возврат данныеответа.response.image;
				конецесли;	
			конецесли;
		конецесли;
	конецесли;
	возврат неопределено;
КонецФункции

//Создание векторной базы OpenAI
//Результат - id базы или неопределено, если база не создана
//имя - имя базы
//провайдер - ссылка на элемент справочника БИИ_Провайдеры
Функция СоздатьВекторнуюБазу(имя,провайдер) экспорт
	Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Authorization", "Bearer "+провайдер.ключ);
	Запрос = Новый HTTPЗапрос("v1/vector_stores", Заголовки);
	данные = новый структура;
	данные.Вставить("name",имя);
	ЗаписьJSON = новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON,данные);
	строказапроса = ЗаписьJSON.Закрыть();
	Запрос.УстановитьТелоИзСтроки(строказапроса);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	если Ответ.КодСостояния=200 тогда
		ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
		данныеответа = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		возврат данныеответа.id;
	иначе
		возврат неопределено;
	конецесли;	
КонецФункции	

//Загрузка файла в хранилище OpenAI
//Результат - id файла или неопределено, если файл не загружен
//имяфайла - имя файла
//данныефайла - двоичные данные файла
//провайдер - ссылка на элемент справочника БИИ_Провайдеры
Функция ЗагрузитьФайл(имяфайла, данныефайла, провайдер) экспорт
	Разделитель = СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
	Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Authorization", "Bearer "+провайдер.ключ);
	Заголовки.Вставить("Content-Type", "multipart/form-data; boundary="+Разделитель);
	Запрос = Новый HTTPЗапрос("v1/files", Заголовки);
	
	РазделительСтрок = Символы.ВК + Символы.ПС;
	ТелоЗапроса = Запрос.ПолучитьТелоКакПоток();
	ЗаписьДанных = Новый ЗаписьДанных(ТелоЗапроса, КодировкаТекста.UTF8, ПорядокБайтов.LittleEndian, "", "", Ложь);
	
	ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель + РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""purpose""");
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку("assistants");
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	
	ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель + РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; name=""file""; filename="""+имяфайла+"""");
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: text/plain");
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);
	ЗаписьДанных.Записать(данныефайла);
	ЗаписьДанных.ЗаписатьСтроку(РазделительСтрок);

	ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель + "--" + РазделительСтрок);
	ЗаписьДанных.Закрыть();	
	
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	если Ответ.КодСостояния=200 тогда
		ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
		данныеответа = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		возврат данныеответа.id;
	иначе
		возврат неопределено;
	конецесли;	
КонецФункции	

//Размещение файла в векторной базе OpenAI
//Результат - id файла в векторной базе или неопределено, если файл не размещен
//база - id векторной базы
//идфайла - id файла в хранилище
//провайдер - ссылка на элемент справочника БИИ_Провайдеры
Функция РазместитьФайл(база, идфайла, провайдер) экспорт
	Соединение = Новый HTTPСоединение("api.openai.com",,,,,,новый ЗащищенноеСоединениеOpenSSL());
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("Authorization", "Bearer "+провайдер.ключ);
	Запрос = Новый HTTPЗапрос("v1/vector_stores/"+база+"/files", Заголовки);
	данные = новый структура;
	данные.Вставить("file_id",идфайла);
	ЗаписьJSON = новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON,данные);
	строказапроса = ЗаписьJSON.Закрыть();
	Запрос.УстановитьТелоИзСтроки(строказапроса);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	если Ответ.КодСостояния=200 тогда
		ОтветСтрока = Ответ.ПолучитьТелоКакСтроку();
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ОтветСтрока);	
		данныеответа = ПрочитатьJSON(ЧтениеJSON);
		ЧтениеJSON.Закрыть();
		возврат данныеответа.id;
	иначе
		возврат неопределено;
	конецесли;	
КонецФункции	

//Получение результата выполнения запроса
//Результат - табличный документ не более 1000 строк
//текстЗапроса - текст запроса, строка
//формат - формат вывода результата, строка содержащая одно из перечисленных значений:
//таблица, график, гистограмма, круг
//по умолчанию таблица
Функция ПолучитьРезультатВыполненияЗапроса(текстЗапроса, формат="таблица") экспорт
	результат = новый ТабличныйДокумент;
	запрос=новый Запрос;
	запрос.Текст=ТекстЗапроса;
	попытка
		тзр = запрос.Выполнить().Выгрузить();
		для каждого к из тзр.Колонки цикл
			если стрнайти(строка(к.типзначения),"Число")>0 тогда
				имязначения=к.Имя;
				прервать;
			конецесли;	
		конеццикла;
		для каждого к из тзр.Колонки цикл
			если стрнайти(строка(к.типзначения),"Число")=0 тогда
				имяточки=к.Имя;
				прервать;
			конецесли;	
		конеццикла;
		если формат="график" тогда
			макет = ПолучитьОбщийМакет("БИИ_ДиаграммаГрафик");
			диаграмма = макет.Рисунки.D1.Объект;    
			диаграмма.СерииВСтроках = ложь;
			диаграмма.Обновление = ложь;
			диаграмма.Очистить();
			диаграмма.ОтображатьЗаголовок = Ложь;
			сч = 0;
			для каждого стр из тзр цикл
				серия = диаграмма.УстановитьСерию("серия");
				серия.текст = "результат";
				точка = диаграмма.УстановитьТочку(стр[имяточки]);
				если точка<>неопределено тогда
					диаграмма.точки[сч].текст = стр[имяточки];
				конецесли;	
				диаграмма.УстановитьЗначение(сч, серия, стр[имязначения], ,);
				сч = сч+1;
			конеццикла;			
			результат.Вывести(макет);
		иначеесли формат="гистограмма" тогда
			макет = ПолучитьОбщийМакет("БИИ_ДиаграммаГистограмма");
			диаграмма = макет.Рисунки.D1.Объект;    
			диаграмма.СерииВСтроках = ложь;
			диаграмма.Обновление = ложь;
			диаграмма.Очистить();
			диаграмма.ОтображатьЗаголовок = Ложь;
			сч = 0;
			для каждого стр из тзр цикл
				серия = диаграмма.УстановитьСерию("серия");
				серия.текст = "результат";
				точка = диаграмма.УстановитьТочку(стр[имяточки]);
				если точка<>неопределено тогда
					диаграмма.точки[сч].текст = стр[имяточки];
				конецесли;	
				диаграмма.УстановитьЗначение(сч, серия, стр[имязначения], ,);
				сч = сч+1;
			конеццикла;			
			результат.Вывести(макет);
		иначеесли формат="круг" тогда
			макет = ПолучитьОбщийМакет("БИИ_ДиаграммаКруг");
			диаграмма = макет.Рисунки.D1.Объект;    
			диаграмма.СерииВСтроках = ложь;
			диаграмма.Обновление = ложь;
			диаграмма.Очистить();
			диаграмма.ОтображатьЗаголовок = ложь;
			диаграмма.АвтоУстановкаИменСерий = ложь;
			сч = 0;
			для каждого стр из тзр цикл
				точка = диаграмма.УстановитьТочку("результат");
				точка.текст = "результат";
				серия = диаграмма.УстановитьСерию(стр[имяточки]);
				диаграмма.УстановитьЗначение(точка, сч, стр[имязначения], ,);
				сч = сч+1;
			конеццикла;			
			результат.Вывести(макет);
		иначе	
			для й=1 по тзр.Колонки.Количество() цикл
				результат.Область(1,й).Текст=тзр.Колонки[й-1].Имя;
				результат.Область(1,й).ШиринаКолонки=стрдлина(тзр.Колонки[й-1].Имя);
				результат.Область(1,й).ЦветФона=новый цвет(192,192,192);
			конеццикла;
			для й=1 по тзр.Количество() цикл
				для ы=1 по тзр.Колонки.Количество() цикл
					результат.Область(й+1,ы).Текст = тзр[й-1][ы-1];
					если результат.Область(й+1,ы).ШиринаКолонки<мин(40,стрдлина(строка(тзр[й-1][ы-1]))) тогда
						результат.Область(й+1,ы).ШиринаКолонки = стрдлина(строка(тзр[й-1][ы-1]));
					конецесли;	
				конеццикла;
				если й>999 тогда
					прервать;
				конецесли;
			конеццикла;
			
			если й>999 тогда 
				строкаитог=результат.ВысотаТаблицы+1;
				результат.Область(строкаитог,й).Текст="... еще "+строка(тзр.Количество()-1000);
				результат.Область(строкаитог,й).ЦветФона=новый цвет(192,192,192);
			иначе
				строкаитог=результат.ВысотаТаблицы+1;
				для й=1 по тзр.Колонки.Количество() цикл
					если тзр.колонки[й-1].типзначения.содержиттип(тип("число")) тогда
						результат.Область(строкаитог,й).Текст=тзр.Итог(тзр.колонки[й-1].имя);
					конецесли;	
					результат.Область(строкаитог,й).ЦветФона=новый цвет(192,192,192);
				конеццикла;
			конецесли;
		конецесли;
	исключение
		результат.Очистить();
		результат.Область(1,1).Текст="При выполнении запроса возникла ошибка:";
		результат.Область(2,1).Текст=ОписаниеОшибки();
	конецпопытки;
	возврат результат;
КонецФункции	



//Устаревшее
//Внутренняя функция предварительного исправления промта
//Результат - исправленный промт
//промт - исходный промт
Функция ПолучитьИсправленныйПромт(промт)
	рез = врег(промт);
	началопрошлогодня = формат(началодня(текущаядата()-86400),"ДФ=dd.MM.yyyy");
	конецпрошлогодня = формат(конецдня(текущаядата()-86400),"ДФ=dd.MM.yyyy");
	началопрошлогомесяца = формат(началомесяца(добавитьмесяц(текущаядата(),-1)),"ДФ=dd.MM.yyyy");
	конецпрошлогомесяца = формат(конецмесяца(добавитьмесяц(текущаядата(),-1)),"ДФ=dd.MM.yyyy");
	началопрошлогогода = формат(началогода(добавитьмесяц(текущаядата(),-12)),"ДФ=dd.MM.yyyy");
	конецпрошлогогода = формат(конецгода(добавитьмесяц(текущаядата(),-12)),"ДФ=dd.MM.yyyy");

	рез = стрзаменить(рез,"ПРОШЛЫЙ ДЕНЬ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРОШЛЫМ ДНЕМ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРОШЛОМ ДНЕ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРОШЕДШИЙ ДЕНЬ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ ДНЕМ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ ДНЕ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРЕДЫДУЩИЙ ДЕНЬ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ ДНЕМ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ ДНЕ","ПЕРИОД С "+началопрошлогодня+" ПО "+конецпрошлогодня);
	
	рез = стрзаменить(рез,"ПРОШЛЫМ МЕСЯЦЕМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЛОМ МЕСЯЦЕ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЛЫЙ МЕСЯЦ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ МЕСЯЦЕМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ МЕСЯЦЕ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШИЙ МЕСЯЦ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ МЕСЯЦЕМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ МЕСЯЦЕ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩИЙ МЕСЯЦ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	
	рез = стрзаменить(рез,"ПРОШЛОМ ГОДУ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЛЫМ ГОДОМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЛЫЙ ГОД","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ ГОДУ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШЕМ ГОДОМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРОШЕДШИЙ ГОД","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ ГОДУ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩЕМ ГОДОМ","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);
	рез = стрзаменить(рез,"ПРЕДЫДУЩИЙ ГОД","ПЕРИОД С "+началопрошлогомесяца+" ПО "+конецпрошлогомесяца);

	возврат рез;
КонецФункции	

//Устаревшее
//Внутренняя функция получения чистого SQL запроса
//Результат - текст SQL запроса
//сыройТекст - сырой текст, в котором надо выделить SQL запрос
Функция ПолучитьИсправленныйОтвет(сыройТекст)
	рез = сыройТекст;
	поз = стрнайти(рез,"```");
	если поз>0 тогда
		рез = сред(рез,поз+3);
	конецесли;	
	поз = стрнайти(рез,"```");
	если поз>0 тогда
		рез=лев(рез,поз-1);
	конецесли;
	
	если лев(рез,1)=символы.ПС тогда
		рез = сред(рез,2);
	конецесли;
	
	поз = стрнайти(рез,"SELECT");
	поз2 = стрнайти(рез,"IN (");
	
	если поз>1 и (поз2=0 или поз2>поз) тогда
		рез = сред(рез,поз);
	конецесли;	
	
	если врег(лев(рез,6))<>"SELECT" тогда
		рез = "SELECT "+рез;
	конецесли;
	
	поз = стрнайти(рез,"HAVING");
	если поз>0 тогда
		тстр = сред(рез,поз+7);
		поз = стрнайти(тстр," ");
		имя = лев(тстр,поз-1);
		поз = стрнайти (рез,"AS "+имя);
		если поз>0 тогда
			тстр = лев(рез,поз-2);
			поз = стрнайти(тстр," ",направлениепоиска.СКонца);
			имязаменить = сред(тстр,поз+1);
			рез = стрзаменить(рез,"HAVING "+имя,"HAVING "+имязаменить);
		конецесли;	
	конецесли;	
	
	возврат рез;
КонецФункции

//Устаревшее
//Внутренняя функция транслятор из MySQL в язык запросов 1С
//Результат - текст запроса на языке запросов 1С
//текстзапроса - текст запроса MySQL
//схема - ссылка на элемент справочника БИИ_СхемыБД
Функция ПолучитьТекстЗапроса1С(текстзапроса,схема)
	рез=врег(текстзапроса);
	
	для каждого стр из схема.замена цикл
		рез=стрзаменить(рез,врег(стр.исходник),стр.результат);
	конеццикла;
	
	рез=стрзаменить(рез,"CURRENT_DATE()","ДАТАВРЕМЯ("+формат(ТекущаяДата(),"ДФ=гггг,ММ,дд")+")");
	рез=стрзаменить(рез,"CURDATE()","ДАТАВРЕМЯ("+формат(ТекущаяДата(),"ДФ=гггг,ММ,дд")+")");
	рез=стрзаменить(рез,"YEAR","ГОД");
	рез=стрзаменить(рез,"MONTH","МЕСЯЦ");
	рез=стрзаменить(рез,"SELECT","ВЫБРАТЬ");
	рез=стрзаменить(рез,"BETWEEN","МЕЖДУ");
	рез=стрзаменить(рез,"HAVING","ИМЕЮЩИЕ");
	рез=стрзаменить(рез,"ORDER","УПОРЯДОЧИТЬ");
	рез=стрзаменить(рез,"FROM","ИЗ");
	рез=стрзаменить(рез,"INNER","ВНУТРЕННЕЕ");
	рез=стрзаменить(рез,"JOIN","СОЕДИНЕНИЕ");
	рез=стрзаменить(рез,"ON","ПО");
	рез=стрзаменить(рез,"WHERE","ГДЕ");
	рез=стрзаменить(рез,"AND","И");
	рез=стрзаменить(рез,"OR","ИЛИ");
	рез=стрзаменить(рез,"ASC","ВОЗР");
	рез=стрзаменить(рез,"AS","КАК");
	рез=стрзаменить(рез,"GROUP","СГРУППИРОВАТЬ");
	рез=стрзаменить(рез,"BY","ПО");
	рез=стрзаменить(рез,"IN","В");
	рез=стрзаменить(рез,"DESC","УБЫВ");
	рез=стрзаменить(рез,"NOT","НЕ");
	рез=стрзаменить(рез,"DISTINCT","РАЗЛИЧНЫЕ");
	рез=стрзаменить(рез,"COUNT","КОЛИЧЕСТВО");
	рез=стрзаменить(рез,"COUNT(DISTINCT","КОЛИЧЕСТВО(РАЗЛИЧНЫЕ");
	
	
	поз=стрнайти(рез, "LIMIT");
	если поз>0 тогда
		рез="ВЫБРАТЬ ПЕРВЫЕ "+стрзаменить(сред(рез,поз+6),";","")+" "+сред(рез,9,поз-9);
	конецесли;
	
	мс=СтрРазделить(рез," "+символы.ПС,ложь);
	инд=мс.Найти("МЕЖДУ");
	если не инд=неопределено тогда
		нстр=мс[инд+1];
		нстр=стрзаменить(нстр,"'","");
		нстр=стрзаменить(нстр,"-",",");
		нстр="ДАТАВРЕМЯ("+нстр+")";
		мс[инд+1]=нстр;
		нстр=мс[инд+3];
		нстр=стрзаменить(нстр,"'","");
		нстр=стрзаменить(нстр,"-",",");
		нстр="ДАТАВРЕМЯ("+нстр+")";
		мс[инд+3]=нстр;
	конецесли;
	рез=СтрСоединить(мс," ");
	
	
	рез=стрзаменить(рез,"'","""");
	
	возврат рез;
КонецФункции	

//Устаревшее
//Получение текста запроса на языке запросов 1С
//Результат - текст запроса в ответ на вопрос пользователя
//промт - текст вопроса пользователя
//модель - ссылка на элемент справочника БИИ_Модели
//схема - ссылка на элемент справочника БИИ_СхемыБД
//общий_журнал - булево, вносить запись в журнал, по умолчанию выключено
//журнал_ошибок - булево, попробовать выполнить запрос и зафиксировать сообщение об ошибке, по умолчанию выключено
Функция ТекстЗапроса(промт, модель, схема, общий_журнал=ложь, журнал_ошибок=ложь) экспорт
	препромт = схема.ТекстСхемы;
	исправленныйПромт = ПолучитьИсправленныйПромт(промт);
	сыройответ = Генерация(препромт+" "+исправленныйПромт+" SELECT",модель,0);
	исправленныйОтвет = ПолучитьИсправленныйОтвет(сыройответ);
	рез = ПолучитьТекстЗапроса1С(исправленныйОтвет,схема);

	тдата=неопределено;
	если общий_журнал тогда
		зап = регистрысведений.БИИ_ЛогЗапросовБД.СоздатьМенеджерЗаписи();
		зап.Дата = ТекущаяДата();
		тдата=зап.Дата;
		зап.Схема = схема;
		зап.Модель = модель;
		зап.Вопрос = промт;
		зап.СыройЗапрос = сыройответ;
		зап.Запрос1С = рез;
		зап.Записать();
	конецесли;
	если журнал_ошибок тогда
		запрос = новый запрос;
		запрос.Текст = рез;
		попытка
			рз = запрос.Выполнить();
		исключение
			зап = регистрысведений.БИИ_ЛогЗапросовБД.СоздатьМенеджерЗаписи();
			если тдата=неопределено тогда
				зап.Дата = ТекущаяДата();
			иначе	
				зап.Дата = тдата;
			конецесли;	
			зап.Схема = схема;
			зап.Модель = модель;
			зап.Вопрос = промт;
			зап.СыройЗапрос = сыройответ;
			зап.Запрос1С = рез;
			зап.Ошибка = ОписаниеОшибки();
			зап.Записать();
		конецпопытки;	
	конецесли;
	
    возврат рез;
КонецФункции	

//Устаревшее
//Выдает основную схему БД из справочника БИИ_СхемыБД
//Результат - текст схемы
//инструмент - ссылка на элемент справочника БИИ_Инструменты
Функция ПолучитьСхемуБД(инструмент)
	запрос = новый запрос;
	запрос.Текст = 
	"ВЫБРАТЬ
	|	БИИ_СхемыБД.ТекстСхемы КАК ТекстСхемы
	|ИЗ
	|	Справочник.БИИ_СхемыБД КАК БИИ_СхемыБД
	|ГДЕ
	|	БИИ_СхемыБД.Инструмент = &Инструмент";
	запрос.УстановитьПараметр("Инструмент",инструмент);
	выб = запрос.Выполнить().Выбрать();
	если выб.Следующий() тогда
		возврат выб.ТекстСхемы;
	иначе
		возврат "";
	конецесли;
КонецФункции	

